/*
 * Copyright (c) 2017, ETH Zurich.
 * All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 *
 * THIS FILE IS AUTOMATICALLY GENERATED BY SOCKEYE: DO NOT EDIT!
 */

#include <barrelfish/static_assert.h>
#include <barrelfish_kpi/types.h>
#include <target/x86_64/offsets_target.h>
#include <target/x86_64/barrelfish_kpi/paging_target.h>

#include <device_mapping.h>


/* the page tables need to be 4k aligned */
#define X86_64_PTABLE_ALIGNMENT X86_64_BASE_PAGE_SIZE

/* base address of another page table */
#define X86_64_PAGE_TABLE_BASE(base)      (((uint64_t)(uintptr_t)(base) >> 12))

/* base address of a large page (2M)*/
#define X86_64_PAGE_BASE_2M(base)    (((uint64_t)(uintptr_t)(base) >> 21))

/* base address of a huge page (1G)*/
#define X86_64_PAGE_BASE_1G(base)    (((uint64_t)(uintptr_t)(base) >> 30))


/*
 * ============================================================================
 * Structure for the x86_64 upper level page tables PML4 and PDPT
 * ============================================================================
 */

typedef uint64_t x86_64_pdir_t[X86_64_PTABLE_SIZE];

#define PDIR_ENTRY(pa) (uint64_t)(pa)
#define PDIR_ENTRY_INVALID PDIR_ENTRY(0)

/*
 * ============================================================================
 * Structure for the x86_64 leaf page table
 * ============================================================================
 */

struct x86_64_ptable_entry {
    uint64_t        present         :1;
    uint64_t        read_write      :1;
    uint64_t        user_supervisor :1;
    uint64_t        write_through   :1;
    uint64_t        cache_disabled  :1;
    uint64_t        accessed        :1;
    uint64_t        dirty           :1;
    uint64_t        always1         :1;
    uint64_t        global          :1;
    uint64_t        available       :2;
    uint64_t        vtd_snoop       :1;
    uint64_t        attr_index      :1;
    uint64_t        reserved        :8;
    uint64_t        base_addr       :21;
    uint64_t        reserved2       :10;
    uint64_t        available2      :11;
    uint64_t        execute_disable :1;
};


typedef struct x86_64_ptable_entry x86_64_ptable_t[X86_64_PTABLE_SIZE];

/**
 * /brief A page directory table entry to map a device region located at
 *        physical address 'pa'
 */
#define PTABLE_DEVICE_ENTRY(pa)                         \
{                                                       \
    .present          = 1,                              \
    .read_write       = 1,                              \
    .user_supervisor  = 1,                              \
    .write_through    = 0,                              \
    .cache_disabled   = 1,                              \
    .accessed         = 0,                              \
    .dirty            = 0,                              \
    .always1          = 1,                              \
    .global           = 0,                              \
    .available        = 0,                              \
    .vtd_snoop        = 0,                              \
    .attr_index       = 0,                              \
    .reserved         = 0,                              \
    .base_addr        = X86_64_PAGE_BASE_2M(pa),        \
    .reserved2        = 0,                              \
    .available2       = 0,                              \
    .execute_disable  = 0                               \
}


/**
 * /brief A page directory table entry to map a memory region  located at
 *        physical address 'pa'
 */
#define PTABLE_MEMORY_ENTRY(pa)                         \
{                                                       \
    .present          = 1,                              \
    .read_write       = 1,                              \
    .user_supervisor  = 1,                              \
    .write_through    = 0,                              \
    .cache_disabled   = 0,                              \
    .accessed         = 0,                              \
    .dirty            = 0,                              \
    .always1          = 1,                              \
    .global           = 0,                              \
    .available        = 0,                              \
    .vtd_snoop        = 0,                              \
    .attr_index       = 0,                              \
    .reserved         = 0,                              \
    .base_addr        = X86_64_PAGE_BASE_2M(pa),        \
    .reserved2        = 0,                              \
    .available2       = 0,                              \
    .execute_disable  = 0                               \
}

#define PTABLE_ENTRY_INVALID {                          \
    .present          = 0,                              \
    .read_write       = 0,                              \
    .user_supervisor  = 1,                              \
    .write_through    = 0,                              \
    .cache_disabled   = 0,                              \
    .accessed         = 0,                              \
    .dirty            = 0,                              \
    .always1          = 1,                              \
    .global           = 0,                              \
    .available        = 0,                              \
    .vtd_snoop        = 0,                              \
    .attr_index       = 0,                              \
    .reserved         = 0,                              \
    .base_addr        = 0,                              \
    .reserved2        = 0,                              \
    .available2       = 0,                              \
    .execute_disable  = 0                               \
}



#define X86_64_PDIR_TABLE_INDEX(va) X86_64_PAGE_BASE_2M(va)
#define X86_64_PDPT_TABLE_INDEX(va) X86_64_PAGE_BASE_1G(va)
#define X86_64_PML4_TABLE_INDEX(va) X86_64_PML4_BASE(va)


x86_64_ptable_t x86_64_pdir[%u][%u]
    __attribute__((aligned(X86_64_PTABLE_ALIGNMENT), section(".pagetables.l2"))) =
{
    %s
};



x86_64_pdir_t x86_64_pdpt[%u]
__attribute__((aligned(X86_64_PTABLE_ALIGNMENT), section(".pagetables.l1"))) =
{
    %s
};

x86_64_pdir_t x86_64_pml4
__attribute__((aligned(X86_64_PTABLE_ALIGNMENT), section(".pagetables.l0"))) =
{
    %s
};

extern uint64_t __pagetables_end;

struct device_mappings device_mappings
__attribute__((aligned(X86_64_PTABLE_ALIGNMENT), section(".devmappings.maps"))) =
{
    .magic = DEVICE_MAPPINGS_MAGIC,
    .count = %u,
    .ptflags = 0x3,
    .ptroot = (uint64_t)&x86_64_pml4,
    .ptend = (uint64_t)(&__pagetables_end),
    .mappings = {
        %s
        DEVICE_MAPPING_ENTRY(0,0,INVALID)
    }
};
